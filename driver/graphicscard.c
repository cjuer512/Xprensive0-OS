//2026.1.21由于我实在是真的真的没时间写改这个了（明天要有合格考，我还得复习），我就让ai帮忙写了下调试了下。
//我也不知道为什么这个能运行成功，但既然能运行我就先别管问什么了
// graphicscard.c - 经过验证的显卡驱动
#include "stdint.h"
#include "driverp.h"

#define VGA_MEMORY 0xA0000
void vga_clear_screen(uint8_t color) {
    uint8_t *vga_buffer = (uint8_t*)VGA_MEMORY;
    for (int i = 0; i < 320 * 200; i++) {
        vga_buffer[i] = color;
    }
}
void vga_set_mode_13h(void) {
    // 禁用中断
    __asm__ volatile ("cli");
    
    // 1. 设置MISC输出寄存器
    outb(0x3C2, 0x63);
    
    // 2. 序列器寄存器 - 解锁扩展寄存器
    outb(0x3C4, 0x00); outb(0x3C5, 0x03);
    outb(0x3C4, 0x01); outb(0x3C5, 0x01);
    outb(0x3C4, 0x02); outb(0x3C5, 0x0F);
    outb(0x3C4, 0x03); outb(0x3C5, 0x00);
    outb(0x3C4, 0x04); outb(0x3C5, 0x0E);
    
    // 3. 取消CRTC寄存器保护
    outb(0x3D4, 0x11);
    outb(0x3D5, inb(0x3D5) & 0x7F);
    
    // 4. CRTC寄存器 - 320x200 256色模式
    outb(0x3D4, 0x00); outb(0x3D5, 0x5F);
    outb(0x3D4, 0x01); outb(0x3D5, 0x4F);
    outb(0x3D4, 0x02); outb(0x3D5, 0x50);
    outb(0x3D4, 0x03); outb(0x3D5, 0x82);
    outb(0x3D4, 0x04); outb(0x3D5, 0x54);
    outb(0x3D4, 0x05); outb(0x3D5, 0x80);
    outb(0x3D4, 0x06); outb(0x3D5, 0xBF);
    outb(0x3D4, 0x07); outb(0x3D5, 0x1F);
    outb(0x3D4, 0x08); outb(0x3D5, 0x00);
    outb(0x3D4, 0x09); outb(0x3D5, 0x41);
    outb(0x3D4, 0x0A); outb(0x3D5, 0x00);
    outb(0x3D4, 0x0B); outb(0x3D5, 0x00);
    outb(0x3D4, 0x0C); outb(0x3D5, 0x00);
    outb(0x3D4, 0x0D); outb(0x3D5, 0x00);
    outb(0x3D4, 0x0E); outb(0x3D5, 0x00);
    outb(0x3D4, 0x0F); outb(0x3D5, 0x00);
    outb(0x3D4, 0x10); outb(0x3D5, 0x9C);
    outb(0x3D4, 0x11); outb(0x3D5, 0x0E);
    outb(0x3D4, 0x12); outb(0x3D5, 0x8F);
    outb(0x3D4, 0x13); outb(0x3D5, 0x28);
    outb(0x3D4, 0x14); outb(0x3D5, 0x1F);
    outb(0x3D4, 0x15); outb(0x3D5, 0x96);
    outb(0x3D4, 0x16); outb(0x3D5, 0xB9);
    outb(0x3D4, 0x17); outb(0x3D5, 0xA3);
    outb(0x3D4, 0x18); outb(0x3D5, 0xFF);
    
    // 5. 图形控制器
    outb(0x3CE, 0x00); outb(0x3CF, 0x00);
    outb(0x3CE, 0x01); outb(0x3CF, 0x00);
    outb(0x3CE, 0x02); outb(0x3CF, 0x00);
    outb(0x3CE, 0x03); outb(0x3CF, 0x00);
    outb(0x3CE, 0x04); outb(0x3CF, 0x00);
    outb(0x3CE, 0x05); outb(0x3CF, 0x40);  // 256色模式
    outb(0x3CE, 0x06); outb(0x3CF, 0x05);  // 图形模式
    outb(0x3CE, 0x07); outb(0x3CF, 0x0F);
    outb(0x3CE, 0x08); outb(0x3CF, 0xFF);
    
    // 6. 属性控制器 - 关键修复！正确设置调色板
    uint8_t status = inb(0x3DA);  // 重置索引翻转
    
    // 先设置所有调色板索引为0-15
    for (int i = 0; i < 16; i++) {
        outb(0x3C0, i);       // 索引
        outb(0x3C0, i);       // 数据
    }
    
    // 设置属性控制器模式
    outb(0x3C0, 0x10);       // 模式控制寄存器索引
    outb(0x3C0, 0x41);       // 启用图形模式，禁用属性控制器
    
    outb(0x3C0, 0x11);       // 边框颜色索引
    outb(0x3C0, 0x00);       // 黑色边框
    
    outb(0x3C0, 0x12);       // 颜色平面使能
    outb(0x3C0, 0x0F);       // 所有平面
    
    outb(0x3C0, 0x13);       // 水平像素平移
    outb(0x3C0, 0x00);
    
    outb(0x3C0, 0x14);       // 颜色选择
    outb(0x3C0, 0x00);
    
    // 关键！启用属性控制器
    outb(0x3C0, 0x20);
    
    // 7. 初始化调色板为灰度
    outb(0x3C8, 0);  // 从索引0开始
    for (int i = 0; i < 256; i++) {
        outb(0x3C9, i >> 2);   // R
        outb(0x3C9, i >> 2);   // G  
        outb(0x3C9, i >> 2);   // B
    }
    
    // 重新启用中断
    __asm__ volatile ("sti");
    
    // 8. 清屏为黑色
    vga_clear_screen(0);
}

void vga_set_palette_color(uint8_t index, uint8_t r, uint8_t g, uint8_t b) {
    outb(0x3C8, index);
    outb(0x3C9, r >> 2);  // VGA是6位颜色
    outb(0x3C9, g >> 2);
    outb(0x3C9, b >> 2);
}

void vga_put_pixel(int x, int y, uint8_t color) {
    uint8_t *vga_buffer = (uint8_t*)VGA_MEMORY;
    if (x >= 0 && x < 320 && y >= 0 && y < 200) {
        vga_buffer[y * 320 + x] = color;
    }
}

